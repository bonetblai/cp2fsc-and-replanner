#summary Documentation for cp2fsc.
#sidebar TableOfContents

= Planning and Control Problems =

The model from which finite-state controllers are derived stands for a class of contingent planning problems. For problems in this class, we make three assumptions. First, that actions are deterministic and thus all uncertainty results from incomplete information in the initial situation. Second, that actions may have conditional effects but no preconditions, and thus are always executable. And third, that sensing is passive meaning that the set of observable fluents is fixed and does not depend on the action taken. The contingent planning problem remains challenging even under these assumptions, and in particular, the controllers that we obtain from these models often work when the assumption of determinism is dropped.

Under these assumptions, we adopt a syntax for expressing contingent problems similar to the one used for defining classical problems P=(F, I, A, G), where F is the set of fluents, I and G stand for the initial and goal situations, and A is the set of actions, except for the following features.

Actions a in A have all empty preconditions but may have a number of conditional effects C → C, where C is a set of fluent literals and C is either one such set or one such literal. We sometimes write them as a : C → C when we want to indicate the action name.

The initial situation I is given by a set of clauses over the fluents in F so the possible initial states are the truth valuations over F that satisfy I.

A set D of axioms or ramification rules r ⇐ C are used to define a set of _non-primitive fluents_ r ∈ R, where C is a set of literals defined over the _primitive fluents_ in F (Thiebaux, Hoffmann, and Nebel 2005). The sets R and F are disjoint, and we allow non-primitive fluents in the body C of conditional effects C → C and goals, but we do not allow them in the heads C.

A state s is a truth valuation over the primitive fluents that defines the truth value of the non-primitive fluents r ∈ R through the axioms:

  * The fluent r is true in state s iff there is an axiom r ⇐ C such that C is true in s.

The observable fluents or simply the observables refer to a set O ⊆ R of non-primitive fluents whose truth value in a given state s is known to the agent. An observation o represents the conjunction of O-literals that are true in a given state. We refer to the observation that corresponds to the state s as o(s) and to the set of all possible observations as O^*^. Clearly, the size of O^∗^ is exponential in the number of observable fluents. The observables along with the set of axioms defining them constitute what is called the sensor model, that relates the true but hidden state s with the information o(s) available to the agent.

These elements define the class of contingent problems considered, that we call Partially Observable Deterministic Control Problems (PODCPs), abbreviated simply as control problems and denoted by tuples P=(F, I, A, G, R, O, D) where:

  * F is a set of (primitive) fluents,
  * I is a set of F-clauses representing the initial situation,
  * A is a set of deterministic actions with conditional effects but no preconditions,
  * G is a set of literals representing the goal situation,
  * R is a set of non-primitive fluents,
  * O is the set of observable fluents, O ⊆ R, and
  * D is the set of axioms defining the fluents in R.

In PODCPs, the initial situation defines a set S,,0,, of possible initial states s,,0,,, and from any such state, a sequence of actions (a,,0,,, a,,1,,, ..., a,,n,,) defines a unique trajectory (s,,0,,, a,,0,,, ... , a,,n,,, s,,n+1,,) of state-action pairs, and a unique trajectory (o,,0,,, a,,0,,, ... , a,,n,,, o,,n+1,,) of observation-action pairs, that can be obtained by replacing s,,i,, by o(s,,i,,).


= Finite-State Controllers =

Finite-state controllers (FSCs) provide a convenient solution form for PODCP of the type P=(F, I, A, G, R, O, D). Formally, a finite-state controller is a tuple C = (Q, A, O^∗^, δ, q,,0,,) with a non-empty and finite set Q of controller states, sets A and O^∗^ of actions and observations, a (partial) transition function δ that maps observation and controller state pairs (o, q) ∈ O^∗^ × Q into action and controller state pairs (a, q) ∈ A × Q, and an initial controller state q,,0,, ∈ Q. 

Controller states serve as controller memory allowing the selection of different actions given the same observation. A FSC with a single state represents a memoryless controller. 

The transition function can be described with rules of the form (o, q) → (a, q') that express that the transition function for C is defined on the pair (o, q) and maps it into the pair (a, q'). It is also convenient to understand a controller C as a set of such rules, that we express as tuples. Thus we write t ∈ C for a tuple t = (o, q, a, q)
if C is defined over the pair (o, q) and maps it into the pair (a, q). Note, however, that if t = (o, q, a, q( is a tuple in C, C cannot contain a tuple t' /= t with the same (o, q) pair, as δ is a transition function over such pairs.

A finite-state controller C provides, like contingent trees and POMDP policies, an specification of the action a,,i+1,, to do next after a given observation-action sequence (o,,0,,, a,,0,,, ... , a,,i,,, o,,i+1,,). The action to do at time i = 0 is a,,0,, = a if t =(o0, q0, a, q) is in C and o(s0) = o0, and the controller state that results at time i = 1 is q. Similarly, the action to do at time i > 0 is a if o and q are the observation and state at time i, and t = (o, q, a, q( is a tuple in C, and the controller state that results at time i + 1 is then q.

A controller C and an initial state s,,0,, determine a unique trajectory s,,0,,, a,,0,,, ... , a,,i,,, s,,i+1,, ...  of state-action
pairs, and a unique trajectory o,,0,,, a,,0,,, ... , a,,i,,, o,,i+1,,, ... of observation-action pairs. These trajectories terminate at time i + 1 if the controller state at time i + 1 is q and there is no tuple t = (o,,i+1,,, q, a, q) in C defined over the pair (o,,i+1,,, q). If this is not the case, the observation-action trajectory resulting from s,,0,, and C is infinite. We say that a controller C solves a control problem P if all the state-action pair trajectories that it produces, starting in a possible initial state s,,0,, ∈ I, reach a goal state. This is a weak form of solution as it does not demand all state trajectories to *terminate* in a goal state. The difference does not
matter when the goals are observable but is relevant otherwise. 


= Translation =

cp2fsc solves the input PODCP problem P by computing a finite-state controller with N states for P. The FSC is found by solving a *conformant planning problem* P,,N,, that is automatically obtained from P and N. The problem P,,N,, is designed in such a way that any plan for it, necessarily encodes a finite-state controller C,,N,, for P with N controller states.

The problem P,,N,, can be solved with different methods, as recently, many solvers for this class of problems had been developed. In the case of cp2fsc, the conformant problem P,,N,, is translated into a *classical planning problem* K,,T,M,,(P,,N,,) which then can be solved with any classical planner. Thus, cp2fsc works by composing two translations: the first from the control problem P and number N into the conformant problem P,,N,,, and then from the conformant problem P,,N,, into the classical problem K,,T,M,,(P,,N,,).


= Syntax =

The PODCP problem P is expressed with a PDDL-like syntax that is then parsed by cp2fsc in order to generate P,,N,, and then K,,T,M,,(P,,N,,). The syntax for PODCP is the following:


= User's Guide =

If `cp2fsc` is called without arguments, it prints the following usage information:

{{{
   Usage: cp2fsc [--compound-obs-as-fluents]
                 [--fsc-states `<n>`]
                 [--help]
                 [--no-forbid-inconsistent-tuples]
                 [--output-metadata <filename>]
                 [--prefix <prefix>]
                 [--tag-all-literals]
                 [--options=<comma-separated-list-of-options>]
                 <pddl-files>
}}}

`cp2fsc` expects at least one PDDL file describing a problem, but it is typical to have the domain and problem descriptions split in two files. Without any other arguments, `cp2fsc` generates an encoding for a FSC with just 1 state (i.e., a memoryless controller) in the form of a classical planning problem encoded with domain and problem files named '`d.pddl`' and '`p.pddl`' respectively. The number of controller states can be specified with the option '`--fsc-states <n>`', while the prefix '`<prefix>`' can be added to the names of the files if the option '`--prefix <prefix>`' is used.

The option `'--output-metadata <filename>'` can be used to tell `cp2fsc` to write to the file named '`<filiename>`' some data associated with the problem, FSC and translation. If a prefix is specified, it is appended at the beginning of the string defining name of the output file.

The option '`--no-forbid-inconsistent-tuples`' can be used to generate a planning problem whose solution does not necessarily correspond to a FSC because the set of tuples C defining the FSC may contain inconsistent pairs of tuples. This option exists because sometimes the resulting classical problem can be solved with tailored and specialized SAT-based solvers.

The option '`--tag-all-literals`' is used to enable the tagging of all literals when doing the K,,T,M,, translation, instead of just tagging the strictly necessary literals. The use of this option changes the translation, but still remains a valid translation. However, its use proves beneficial in terms of performance in some domains, not all.

The option `'--compound-observations-as-fluents'` is not yet supported and should not be passed.

Finally, different options can be passed to `cp2fsc` with the option '`--options=<comma-separated-list-of-options>`' together with a list of different options, whose main purpose is to generate output about the different translation processes.



= Examples =