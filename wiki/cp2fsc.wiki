#summary Documentation for cp2fsc.

= Planning and Control Problems =

The model from which finite-state controllers are derived stands for a class of contingent planning problems. For problems in this class, we make three assumptions. First, that actions are deterministic and thus all uncertainty results from incomplete information in the initial situation. Second, that actions may have conditional effects but no preconditions, and thus are always executable. And third, that sensing is passive meaning that the set of observable fluents is fixed and does not depend on the action taken. The contingent planning problem remains challenging even under these assumptions, and in particular, the controllers that we obtain from these models often work when the assumption of determinism is dropped.

Under these assumptions, we adopt a syntax for expressing contingent problems similar to the one used for defining classical problems P=(F, I, A, G), where F is the set of fluents, I and G stand for the initial and goal situations, and A is the set of actions, except for the following features.

Actions a in A have all empty preconditions but may have a number of conditional effects C → C, where C is a set of fluent literals and C is either one such set or one such literal. We sometimes write them as a : C → C when we want to indicate the action name.

The initial situation I is given by a set of clauses over the fluents in F so the possible initial states are the truth valuations over F that satisfy I.

A set D of axioms or ramification rules r ⇐ C are used to define a set of _non-primitive fluents_ r ∈ R, where C is a set of literals defined over the _primitive fluents_ in F (Thiebaux, Hoffmann, and Nebel 2005). The sets R and F are disjoint, and we allow non-primitive fluents in the body C of conditional effects C → C and goals, but we do not allow them in the heads C.

A state s is a truth valuation over the primitive fluents that defines the truth value of the non-primitive fluents r ∈ R through the axioms:

  * The fluent r is true in state s iff there is an axiom r ⇐ C such that C is true in s.

The observable fluents or simply the observables refer to a set O ⊆ R of non-primitive fluents whose truth value in a given state s is known to the agent. An observation o represents the conjunction of O-literals that are true in a given state. We refer to the observation that corresponds to the state s as o(s) and to the set of all possible observations as O^*^. Clearly, the size of O^∗^ is exponential in the number of observable fluents. The observables along with the set of axioms defining them constitute what is called the sensor model, that relates the true but hidden state s with the information o(s) available to the agent.

These elements define the class of contingent problems considered, that we call Partially Observable Deterministic Control Problems (PODCPs), abbreviated simply as control problems and denoted by tuples P=(F, I, A, G, R, O, D) where:

  * F is a set of (primitive) fluents,
  * I is a set of F-clauses representing the initial situation,
  * A is a set of deterministic actions with conditional effects but no preconditions,
  * G is a set of literals representing the goal situation,
  * R is a set of non-primitive fluents,
  * O is the set of observable fluents, O ⊆ R, and
  * D is the set of axioms defining the fluents in R.

In PODCPs, the initial situation defines a set S,,0,, of possible initial states s,,0,,, and from any such state, a sequence of actions (a,,0,,, a,,1,,, ..., a,,n,,) defines a unique trajectory (s,,0,,, a,,0,,, ... , a,,n,,, s,,n+1,,) of state-action pairs, and a unique trajectory (o,,0,,, a,,0,,, ... , a,,n,,, o,,n+1,,) of observation-action pairs, that can be obtained by replacing s,,i,, by o(s,,i,,).

= Finite-State Controllers =

Finite-state controllers (FSCs) provide a convenient solution form for PODCP of the type P=(F, I, A, G, R, O, D). Formally, a finite-state controller is a tuple C = (Q, A, O^∗^, δ, q,,0,,) with a non-empty and finite set Q of controller states, sets A and O^∗^ of actions and observations, a (partial) transition function δ that maps observation and controller state pairs (o, q) ∈ O^∗^ × Q into action and controller state pairs (a, q) ∈ A × Q, and an initial controller state q,,0,, ∈ Q. 

Controller states serve as controller memory allowing the selection of different actions given the same observation. A FSC with a single state represents a memoryless controller. 

The transition function can be described with rules of the form (o, q) → (a, q') that express that the transition function for C is defined on the pair (o, q) and maps it into the pair (a, q'). It is also convenient to understand a controller C as a set of such rules, that we express as tuples. Thus we write t ∈ C for a tuple t = (o, q, a, q)
if C is defined over the pair (o, q) and maps it into the pair (a, q). Note, however, that if t = (o, q, a, q( is a tuple in C, C cannot contain a tuple t' /= t with the same (o, q) pair, as δ is a transition function over such pairs.



= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages