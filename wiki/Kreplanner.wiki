#summary Documentation for K-Replanner.
#sidebar TableOfContents

= Planning Models =

The language is a simple extension of STRIPS with conditional effects, negation, an uncertain initial situation, and sensing. More precisely, a partially observable problem is a tuple P = (F, O, I, G, M) where F stands for the fluent symbols, O for the actions, I is a set of clauses over F defining the initial situation, G is a set of F-literals defining the goal situation, and M represents the sensor model. An action a has preconditions given by a set of literals, and a set of conditional effects a : C → L where C is a set of literals and L is a literal. The sensor model M is a set of pairs (C,L) where C is a set of literals and L is a positive literal. The pair indicates that the truth value of L is observable when C is true. Each pair (C,L) can be understood as a sensor that is active when C is true, or as an information-gathering action with precondition C that reveals the boolean value of L. Unlike the other actions, however, these sensing actions trigger when their preconditions hold. We use ¬L to denote the
complement of L.


= Translation =

asdasd asd sda

= Syntax = 

Contingent problems P are expressed with a  PDDL-like syntax that is parsed by `k-replanner` in order to generate the different classucal translations. The syntax for writing domains and problems is the following:

{{{
<domain> ::= (define (domain <name>) <domain-item>*)
<domain-item> ::= (:requirements <require-keyword>*)
                | (:types <type-decl>*)
                | (:constants <typed-obj>*)
                | (:predicates  <predicate>*)
                | <structure>*

<type-decl> ::= <type>+ | <type>+ - <type>
<typed-obj> ::= <obj>+ | <obj>+ - <type>
<predicate> ::= (<name> <parameter>*)
<structure> ::= <action> | <sensor>

<action> ::= (:action <name> <action-item>*)
<sensor> ::= (:sensor <name> <sensor-item>*)

<action-item> ::= :parameters (<parameter>*)
                 | :precondition <condition>
                 | :effect <effect>

<sensor-item> ::= :parameters (<parameter>*)
                 | :condition <condition>
                 | :sensed <fluent>+

<parameter>  ::= <variable>+ | <variable>+ - <type>
<condition>  ::= <fluent> | (and <fluent>*)

<effect>     ::= <single-eff> | (and <single-eff>*)
<single-eff> ::= <atomic-eff>
               | (when <condition> <atomic-eff>*)
               | (forall (<parameters>) <effect>)
<atomic-eff> ::= <fluent> | (not <fluent>)


<problem> ::= (define (problem <name>) <problem-item>*)
<problem-item> ::= (:domain <name>)
                 | (:requirements <require-keyword>*)
                 | (:init <init-item>*)
                 | (:hidden <hidden-item>*)
                 | (:goal <goal-decl>)

<init-item>   := <fluent> | (not (fluen)) | (invariant <fluent>+)
<hidden-item> ::= <fluent>
<goal-decl>   ::= <single-goal> | (and <single-goal>*)
<sigle-goal>  ::= <fluent> | (not <fluent>)
}}}


= User's Guide =

If `k-replanner` is called without arguments, it prints the following usage information:

{{{
   Usage: k_replanner [--help]
                      [--max-time <time>]
                      [--no-print-plan]
                      [--prefix <prefix>]
                      [--no-remove-intermediate-files]
                      [--use-{ff|lama|m|mp}]
                      [--options=<options>]
                      <pddl-files>

}}}

`k-replanner` expects at least one PDDL file describing a problem, but it is typical to have the domain and problem descriptions split in two files. Without any other arguments, `k-replanner` tries to generate an execution that ends at a goal state, or discover that such an execution does not exist. This is guaranteed to contingent planning problems that satisfies the conditions for completeness. The execution is generated by calling a classical planner (default FF) over a sequence of classical planning problems that are generated along the execution. 

The options '`--use={ff|lama|m|mp}`' are used to change the classical planner that is called.

If the user want to see what are the classical plans that are solved along the execution, then s/he should use the option '`--no-remove-intermediate-files`'.

The option '`--no-print-plan`' is used to tell `k-replanner` to not print the complete sequence of actions (plan) during the execution. The default is to print such sequence of actions.

The option '`--max-time <time>`' is to used to put an absolute bound on the cumulative time incurred by the classical planner when solving classical problems. If this time is surpassed, the execution terminates and fails.

The option '`--prefix <prefix>`' is for future use and does nothing in the current implementation.

Finally, different options can be passed to `cp2fsc` with '`--options=<comma-separated-list-of-options>`' together with a list of different options, whose main purpose is to generate output about the different translation processes and their results.


= Examples =

K-Replanner is tested on instances from several domains, all of which can be naturally encoded as simple partially observable problems. Several of these domains are beyond the reach of simple replanners as non-trivial beliefs that integrate the observations gathered need to be maintained. In the K-Replanner, this is achieved by keeping track of literals while maintaining the invariants. The domains are:

  * *Freespace:* the agent needs to reach a final position by moving through unknown terrain. Each cell of the grid is either blocked or clear. As the agent moves, it senses the status of adjacent cells.

  * *Doors:* the agent moves in a grid to reach a final position, yet is has to cross doors whose positions are only partially known.

  * *Wumpus:* a variant of the well-known domain where the agent moves in a grid to reach a final position while avoiding multiple wumpus monsters. As the agent moves, it smells the stench of nearby wumpuses.

  * *Kill-wumpus:* a variation of the above in which the agent must locate and kill the single wumpus in the grid.

  * *Colored-balls:* the agent navigates a grid to pick up and deliver balls of different colors to destinations that depend on the color of the ball. The positions and colors of the balls are unknown, but when the agent is at a position, he observes if there are balls in there, and if so, their colors.

  * *Trail:* the agent must follow a trail of stones til the end. The shape and length of the trail are not known. The agent cannot get off trail but can observe the presence of stones in the nearby cells.

 