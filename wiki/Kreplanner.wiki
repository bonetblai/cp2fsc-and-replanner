#summary Documentation for K-Replanner.
#sidebar TableOfContents

= Planning Models =


= Translation =


= Syntax = 

Contingent problems P are expressed with a  PDDL-like syntax that is parsed by `k-replanner` in order to generate the different classucal translations. The syntax for writing domains and problems is the following:

{{{
<domain> ::= (define (domain <name>) <domain-item>*)
<domain-item> ::= (:requirements <require-keyword>*)
                | <types-decl>
                | (:constants <typed-obj-list>)
                | (:predicates  <predicate-list>)
                | <structure>*

<types-decl> ::= XXXX
<typed-obj-list> ::= XXXX
<predicate-list> ::= XXXX
<structure> ::= <action> | <axiom> | <observable> | <sticky>

<action> ::= (:action <name> <action-item>*)
<sensor> ::= (:sensor <name> <sensor-item>*)

<action-item> ::= :parameters (<parameter>*)
                 | :precondition <condition>
                 | :effect <effect>

<sensor-item> ::= :parameters (<parameter>*)
                 | :condition <condition>
                 | :sensed <fluent>+

<parameters> ::= <variable>+ | <variable>+ - <type>
<condition>  ::= <fluent> | (and <fluent>*)

<effect>     ::= <single-eff> | (and <single-eff>*)
<single-eff> ::= <atomic-eff>
               | (when <condition> <atomic-eff>*)
               | (forall (<parameters>) <effect>)
<atomic-eff> ::= <fluent> | (not <fluent>)


<problem> ::= (define (problem <name>) <problem-item>*)
<problem-item> ::= (:domain <name>)
                 | (:requirements <require-keyword>*)
                 | (:init <init-item>*)
                 | (:hidden <hidden-item>*)
                 | (:goal <goal-decl>)

<init-item>   := <fluent> | (not (fluen)) | (invariant <fluent>+)
<hidden-item> ::= <fluent>
<goal-decl>   ::= <single-goal> | (and <single-goal>*)
<sigle-goal>  ::= <fluent> | (not <fluent>)
}}}


= User's Guide =

If `k-replanner` is called without arguments, it prints the following usage information:

{{{
   Usage: k_replanner [--help]
                      [--max-time <time>]
                      [--no-print-plan]
                      [--prefix <prefix>]
                      [--no-remove-intermediate-files]
                      [--use-{ff|lama|m|mp}]
                      [--options=<options>]
                      <pddl-files>

}}}

`k-replanner` expects at least one PDDL file describing a problem, but it is typical to have the domain and problem descriptions split in two files. Without any other arguments, `k-replanner` tries to generate an execution that ends at a goal state, or discover that such an execution does not exist. This is guaranteed to contingent planning problems that satisfies the conditions for completeness. The execution is generated by calling a classical planner (default FF) over a sequence of classical planning problems that are generated along the execution. 

The options '`--use={ff|lama|m|mp}`' are used to change the classical planner that is called.

If the user want to see what are the classical plans that are solved along the execution, then s/he should use the option '`--no-remove-intermediate-files`'.

The option '`--no-print-plan`' is used to tell `k-replanner` to not print the complete sequence of actions (plan) during the execution. The default is to print such sequence of actions.

The option '`--max-time <time>`' is to used to put an absolute bound on the cumulative time incurred by the classical planner when solving classical problems. If this time is surpassed, the execution terminates and fails.

The option '`--prefix <prefix>`' is for future use and does nothing in the current implementation.

Finally, different options can be passed to `cp2fsc` with '`--options=<comma-separated-list-of-options>`' together with a list of different options, whose main purpose is to generate output about the different translation processes and their results.


= Examples =